import {Component, Input, OnInit} from '@angular/core';
import {Report} from '../report';
import {ActivatedRoute} from '@angular/router';
import {ReportService} from '../report.service';
import {Location} from '@angular/common';
import {Vulnerability} from '../vulnerability';
import {Impact} from '../impact';

@Component({
    selector: 'app-report-modify',
    templateUrl: './report-modify.component.html',
    styleUrls: ['./report-modify.component.css']
})
export class ReportModifyComponent implements OnInit {

    @Input() currentReport: Report;
    vulnList: Vulnerability[];
    @Input() selectedVulnerability: Vulnerability;
    @Input() currentSelectedVulnerabilities: Vulnerability[] = [];
    impactLevels: Impact[] = [];
    @Input() focusedVuln: Vulnerability = new Vulnerability();


    constructor(private route: ActivatedRoute,
                private reportService: ReportService,
                private location: Location) {
    }

    ngOnInit() {
        const id = this.route.snapshot.paramMap.get('id');
        if (id == null) {
            this.currentReport = new Report();
            this.currentReport.vulns = [];
        } else {
            this.reportService.getReport(+id).subscribe(report => this.currentReport = report);
        }

        this.reportService.getVulnerabilities()
            .subscribe(vulns => this.vulnList = vulns);

        this.reportService.getImpacts()
            .subscribe(impacts => this.impactLevels = impacts);
        //
        // if (this.vulnList.length) {
        //     this.selectedVulnerability = this.vulnList[0];
        //     this.changedVuln(0);
        // }

        if (this.impactLevels.length) {
            this.focusedVuln.impactLevel = this.impactLevels[0];
        } else {
            this.focusedVuln.impactLevel = new Impact();
        }
    }

    goBack() {
        this.location.back();
    }

    changedVuln(selection: number) {
        if (selection === 1 && this.currentSelectedVulnerabilities.length > 0) {
            this.focusedVuln = {...this.currentSelectedVulnerabilities[0]};
        } else {
            this.focusedVuln = {...this.selectedVulnerability};
        }
    }

    addVuln() {
        if (this.focusedVuln.title) {
            this.currentReport.vulns.push({...this.focusedVuln});
        }
    }

    removeVuln() {
        if (this.currentSelectedVulnerabilities) {
            const currentVulns = this.currentReport.vulns;
            this.currentSelectedVulnerabilities.forEach(function (vuln) {
                const index = currentVulns.indexOf(vuln, 0);
                if (index > -1) {
                    currentVulns.splice(index, 1);
                }
            });
        }
    }

    permanentRemove() {
        if (this.selectedVulnerability) {
            const index = this.vulnList.indexOf(this.selectedVulnerability);
            if (index > -1) {
                this.vulnList.splice(index, 1);
            }
        }
    }

    permanentAdd() {
        if (this.focusedVuln.title) {
            const createdVuln = {...this.focusedVuln};
            this.vulnList.push(createdVuln);
            this.vulnList.sort((n1, n2) => {
                return n1.impactLevel._id - n2.impactLevel._id;
            });
            this.selectedVulnerability = createdVuln;
        }
    }
}
