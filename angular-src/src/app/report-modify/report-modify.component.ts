import {Component, Input, OnInit} from '@angular/core';
import {Report} from '../report';
import {ActivatedRoute} from '@angular/router';
import {ReportService} from '../report.service';
import {Location} from '@angular/common';
import {Vulnerability} from '../vulnerability';
import {Impact} from '../impact';

@Component({
    selector: 'app-report-modify',
    templateUrl: './report-modify.component.html',
    styleUrls: ['./report-modify.component.css']
})
export class ReportModifyComponent implements OnInit {

    @Input() currentReport: Report;
    vulnList: Vulnerability[];
    @Input() selectedVulnerability: Vulnerability;
    @Input() currentSelectedVulnerabilities: Vulnerability[] = [];
    impactLevels: Impact[];
    @Input() focusedVuln: Vulnerability = new Vulnerability();
    existingId: number = -1;

    constructor(private route: ActivatedRoute,
                private reportService: ReportService,
                private location: Location) {
    }

    addAndSortReportVulns(report: Report) {
        this.currentReport = report;
        this.currentReport.vulns.sort((n1, n2) => {
            return n1.impactLevel._id - n2.impactLevel._id;
        });
    }

    addAndSortAllVulns(vulns: Vulnerability[]) {
        this.vulnList = vulns;
        this.vulnList.sort((n1, n2) => {
            return (<number><unknown>n1.impactLevel - <number><unknown>n2.impactLevel);
        });
    }

    ngOnInit() {
        const id = this.route.snapshot.paramMap.get('id');
        if (id == null) {
            this.currentReport = new Report();
            this.currentReport.vulns = [];
        } else {
            this.reportService.getReport(+id).subscribe(report => this.addAndSortReportVulns(report));
            this.existingId = +id;
        }

        this.reportService.getVulnerabilities()
            .subscribe(vulns => this.addAndSortAllVulns(vulns));

        this.reportService.getImpacts()
            .subscribe(impacts => this.impactLevels = impacts.sort((n1, n2) => {
                return n1._id - n2._id;
            }));
        //
        // if (this.vulnList.length) {
        //     this.selectedVulnerability = this.vulnList[0];
        //     this.changedVuln(0);
        // }

        if (this.impactLevels.length) {
            this.focusedVuln.impactLevel = this.impactLevels[0];
        } else {
            this.focusedVuln.impactLevel = new Impact();
        }
    }

    goBack() {
        this.location.back();
    }

    changedVuln(selection: number) {
        console.log(this.currentReport.vulns);
        if (selection === 1 && this.currentSelectedVulnerabilities.length > 0) {
            this.focusedVuln = {...this.currentSelectedVulnerabilities[0]};
        } else {
            this.focusedVuln = {...this.selectedVulnerability};
        }
    }

    addVuln() {
        if (this.focusedVuln.title) {
            const newVuln = {...this.focusedVuln};
            this.currentReport.vulns.push(newVuln);
            this.vulnList.sort((n1, n2) => {
                return n1.impactLevel._id - n2.impactLevel._id;
            });
        }
    }

    removeVuln() {
        if (this.currentSelectedVulnerabilities) {
            const currentVulns = this.currentReport.vulns;
            this.currentSelectedVulnerabilities.forEach(function (vuln) {
                const index = currentVulns.indexOf(vuln, 0);
                if (index > -1) {
                    currentVulns.splice(index, 1);
                }
            });
        }
    }

    permanentRemove() {
        if (this.selectedVulnerability) {
            this.reportService.deleteVulnerability(this.selectedVulnerability)
                .subscribe(vuln => this.removeAndSort());
        }
    }

    removeAndSort() {
        const index = this.vulnList.indexOf(this.selectedVulnerability);
        if (index > -1) {
            this.vulnList.splice(index, 1);
        }
    }

    addAndSort(vuln: Vulnerability) {
        this.vulnList.push(vuln);
        this.vulnList.sort((n1, n2) => {
            return (<number><unknown>n1.impactLevel - <number><unknown>n2.impactLevel);
        });
        this.selectedVulnerability = vuln;
    }

    permanentAdd() {
        if (this.focusedVuln.title) {
            const createdVuln = {...this.focusedVuln};
            createdVuln._id = undefined;
            this.reportService.addVulnerability(createdVuln)
                .subscribe(vuln => this.addAndSort(createdVuln));
        }
    }

    addReport() {
        if (this.currentReport.company) {
            if (this.existingId >= 0) {
                this.reportService.updateReport(this.currentReport)
                    .subscribe(report => this.goBack());
            } else {
                this.reportService.addReport(this.currentReport)
                    .subscribe(report => this.goBack());
            }
        }
    }
}
